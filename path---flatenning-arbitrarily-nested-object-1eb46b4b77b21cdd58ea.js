webpackJsonp([9630271022450],{368:function(n,a){n.exports={data:{markdownRemark:{html:'<p>In this post we\'ll solve a small challenge: flatten an arbitrarily nested object into an array of values. Our initial goal should be to destructure the object, removing the keys and leaving values only.</p>\n<p>To achieve this, recursion. While traversing the object, we\'ll check if the object\'s property holds a simple value (like a number) or another object. We apply the function recursively until the returned value is a simple one.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  b<span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>\n  c<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    d<span class="token punctuation">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>\n    e<span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span>\n    f<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      g<span class="token punctuation">:</span> <span class="token string">"4"</span><span class="token punctuation">,</span>\n      h<span class="token punctuation">:</span> <span class="token string">"5"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  i<span class="token punctuation">:</span> <span class="token string">"6"</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">serialize</span> <span class="token operator">=</span> obj <span class="token operator">=></span>\n  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>key <span class="token operator">=></span>\n    <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">?</span> <span class="token function">serialize</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>If we test this function, we\'ll see it returns an array, and depending on the level of nesting, internal arrays as values. To make sure we always have a one-level array, our goal now is to flatten it.</p>\n<p>To do so, we\'ll use the example from a previous post <a href="/flattening-arbitrarily-nested-arrays">Flattening Arbitrarily Nested Arrays</a> to recursively flatten the array until the remaining value is not an array.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> arr <span class="token operator">=></span>\n  arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span>\n    acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">:</span> curr<span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>There you go. The flatten function simply verifies if the <code class="language-text">curr</code> value is an array or not. If it is, it will flatten it again by checking if its items are also arrays or not. That will be done until only simple values are returned. When that happens, <code class="language-text">curr</code> will be appended to the original accumulator (identified by the <code class="language-text">acc</code> parameter).</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">flatten</span><span class="token punctuation">(</span><span class="token function">serialize</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4, 5, 6]</span></code></pre>\n      </div>\n<h3>Composition</h3>\n<p>The initial challenge is solved. Now, to make this look better, why not use functional compositional to achieve a clearer, more beautiful execution order?</p>\n<p>Composition is about putting together small simple functions to achieve a more complex functionality while still maintaing readability. Remember the DOT and KISS principles, respectively <strong>"DO ONE THING"</strong> and <strong>"KEEP IT SIMPLE, STUPID"</strong>.</p>\n<p>Instead of writing one function that does everything, we write multiple functions that are really good at doing one thing only, and compose them together like lego bricks, into higher functionality.</p>\n<p>To achieve this, we\'ll create a composer function that, from an initial value will apply multiple functions in order:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">composer</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> funcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> funcs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">curr</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// es6 version</span>\n<span class="token keyword">const</span> <span class="token function-variable function">composer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> funcs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">curr</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>Then, we compose these two functions together and use the composer anytime we wish to do this same operation:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> objectFlattener <span class="token operator">=</span> <span class="token function">composer</span><span class="token punctuation">(</span>serialize<span class="token punctuation">,</span> flatten<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">objectFlattener</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4, 5, 6]</span></code></pre>\n      </div>',frontmatter:{title:"Flattening an Arbitrarily Nested Object",date:"December 22, 2017",path:"/flatenning-arbitrarily-nested-object",tags:["javascript"],excerpt:"In this post, we'll solve a small challenge: flatten an arbitrarily nested object into an array of values. Our initial goal should be to deestructure the object, removing the keys and leaving values only; then, we should be able to transform the nested array into a single-level array."}}},pathContext:{prev:{html:'<p>Passwords tend to be weak and predictable. That\'s because humans are lazy and end up choosing common passwords like <code class="language-text">123456</code> or <code class="language-text">mickeymouse123</code>. Furthermore, it\'s common for an user to use the same password in multiple different places. That creates problems. For instance, security breaches in one place, like a database, can generate breaches in several others as well.</p>\n<h3>SSH</h3>\n<p>SSH provides a solution to that, because of its cryptographic mechanism. We generate two counterparts: a public key and hash. The public key is specifically created to match that one hash. We place the public key in the server, and any attempts to connect necessarily require the hash.</p>\n<p>Since nothing is perfect, SSH also introduces its own kinds of risks, like the fact that having the hash sitting in your computer means that anyone with access to it will have access to your server. That is topic for later discussions.</p>\n<h4>Generate SSH files in a "safe" place</h4>\n<p>The concept of safe here is intended to mean "not easily loseable". This is important because since we\'re talking of server access, if we configure SSH login and disable password access, that necessarily means if we lose the hash file, <em>we\'ll be locked out of our server</em>.</p>\n<p>So, with the command line go to the <code class="language-text">~/.ssh</code> folder:</p>\n<p><code class="language-text">cd ~/.ssh</code></p>\n<p>Then run <code class="language-text">ssh-keygen -t rsa</code> (-t rsa indicates rsa as encryption type)</p>\n<p>The prompt will show a series of questions like which name you want to give to your key. <strong>Important</strong> in the naming step, make sure not to use the default value, because it\'s likely you already have such file created for other applications in your system. So just provide another name.</p>',id:"/Users/zavareze/projects/zavjsblog/src/pages/2019-02-03-generating-ssh-key/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"Su, 02/19",path:"/generating-an-ssh-key",title:"Generating an SSH key",excerpt:"Plain text password pose a series of security risks to server security. Using SSH is the best alternative to it. Let's learn how today",tags:["nginx","ssh"]}},next:{html:'<p>Sometimes you don\'t want to delegate from a prototype, like mentioned <a href="/glossary-object-create">here</a> and <a href="/glossary-prototypes">here</a>. Instead, you want to have all properties of the prototype copied into the new object. That can be done with <code class="language-text">Object.assign</code>.</p>\n<p>Here\'s a possible implementation of such a behavior:</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">copyFrom</span> <span class="token operator">=</span> ref <span class="token operator">=></span>\n  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>\n    <span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>\n      <span class="token punctuation">{</span>\n        <span class="token operator">...</span>acc<span class="token punctuation">,</span>\n        <span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">:</span> ref<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p><a href="https://repl.it/@zavareze/Objectextend-Assign-Cloning">Live Code on Repl.it</a></p>\n<p>The difference between cloning and prototyping is that the latter is more memory efficient. So it\'s a good idea to use delegation for publicly shared methods, and cloning for properties in order to prevent shared state issues.</p>\n<p><strong>Important</strong>: just as seen previously, object and array direct assingments are shared between instances whereas replacements are instance-specific:</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> somePrototype <span class="token operator">=</span> <span class="token punctuation">{</span> skills<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"ray"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> inst1 <span class="token operator">=</span> <span class="token function">copyFrom</span><span class="token punctuation">(</span>somePrototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> inst2 <span class="token operator">=</span> <span class="token function">copyFrom</span><span class="token punctuation">(</span>somePrototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\ninst1<span class="token punctuation">.</span>skills<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"thunder"</span><span class="token punctuation">;</span>\n\n<span class="token comment">// did it affect \'inst2\'?</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inst2<span class="token punctuation">.</span>skills<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// \'thunder\' Yes, it did</span></code></pre>\n      </div>',id:"/Users/zavareze/projects/zavjsblog/src/pages/2019-02-04-prototype-cloning/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"Su, 02/19",path:"/prototype-cloning",title:"Prototype and Clone",excerpt:"",tags:["prototypes","javascript"]}}}}}});
//# sourceMappingURL=path---flatenning-arbitrarily-nested-object-1eb46b4b77b21cdd58ea.js.map