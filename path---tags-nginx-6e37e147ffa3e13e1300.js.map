{"version":3,"sources":["webpack:///path---tags-nginx-6e37e147ffa3e13e1300.js","webpack:///./.cache/json/tags-nginx.json"],"names":["webpackJsonp","385","module","exports","pathContext","posts","html","id","frontmatter","date","path","title","excerpt","tags","tagName"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAUC,KAAA,m3DAAAC,GAAA,yHAAAC,aAAghEC,KAAA,YAAAC,KAAA,yBAAAC,MAAA,wBAAAC,QAAA,yIAAAC,MAAA,kBAA8PC,QAAA","file":"path---tags-nginx-6e37e147ffa3e13e1300.js","sourcesContent":["webpackJsonp([246017241436493],{\n\n/***/ 385:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"posts\":[{\"html\":\"<p>Passwords tend to be weak and predictable. That's because humans are lazy and end up choosing common passwords like <code class=\\\"language-text\\\">123456</code> or <code class=\\\"language-text\\\">mickeymouse123</code>. Furthermore, it's common for an user to use the same password in multiple different places. That creates problems. For instance, security breaches in one place, like a database, can generate breaches in several others as well.</p>\\n<h3>SSH</h3>\\n<p>SSH provides a solution to that, because of its cryptographic mechanism. We generate two counterparts: a public key and hash. The public key is specifically created to match that one hash. We place the public key in the server, and any attempts to connect necessarily require the hash.</p>\\n<p>Since nothing is perfect, SSH also introduces its own kinds of risks, like the fact that having the hash sitting in your computer means that anyone with access to it will have access to your server. That is topic for later discussions.</p>\\n<h4>Generate SSH files in a \\\"safe\\\" place</h4>\\n<p>The concept of safe here is intended to mean \\\"not easily loseable\\\". This is important because since we're talking of server access, if we configure SSH login and disable password access, that necessarily means if we lose the hash file, <em>we'll be locked out of our server</em>.</p>\\n<p>So, with the command line go to the <code class=\\\"language-text\\\">~/.ssh</code> folder:</p>\\n<p><code class=\\\"language-text\\\">cd ~/.ssh</code></p>\\n<p>Then run <code class=\\\"language-text\\\">ssh-keygen -t rsa</code> (-t rsa indicates rsa as encryption type)</p>\\n<p>The prompt will show a series of questions like which name you want to give to your key. <strong>Important</strong> in the naming step, make sure not to use the default value, because it's likely you already have such file created for other applications in your system. So just provide another name.</p>\",\"id\":\"/Users/zavareze/projects/zavjsblog/src/pages/2019-02-03-generating-ssh-key/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"Su, 02/19\",\"path\":\"/generating-an-ssh-key\",\"title\":\"Generating an SSH key\",\"excerpt\":\"Plain text password pose a series of security risks to server security. Using SSH is the best alternative to it. Let's learn how today\",\"tags\":[\"nginx\",\"ssh\"]}}],\"tagName\":\"nginx\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---tags-nginx-6e37e147ffa3e13e1300.js","module.exports = {\"pathContext\":{\"posts\":[{\"html\":\"<p>Passwords tend to be weak and predictable. That's because humans are lazy and end up choosing common passwords like <code class=\\\"language-text\\\">123456</code> or <code class=\\\"language-text\\\">mickeymouse123</code>. Furthermore, it's common for an user to use the same password in multiple different places. That creates problems. For instance, security breaches in one place, like a database, can generate breaches in several others as well.</p>\\n<h3>SSH</h3>\\n<p>SSH provides a solution to that, because of its cryptographic mechanism. We generate two counterparts: a public key and hash. The public key is specifically created to match that one hash. We place the public key in the server, and any attempts to connect necessarily require the hash.</p>\\n<p>Since nothing is perfect, SSH also introduces its own kinds of risks, like the fact that having the hash sitting in your computer means that anyone with access to it will have access to your server. That is topic for later discussions.</p>\\n<h4>Generate SSH files in a \\\"safe\\\" place</h4>\\n<p>The concept of safe here is intended to mean \\\"not easily loseable\\\". This is important because since we're talking of server access, if we configure SSH login and disable password access, that necessarily means if we lose the hash file, <em>we'll be locked out of our server</em>.</p>\\n<p>So, with the command line go to the <code class=\\\"language-text\\\">~/.ssh</code> folder:</p>\\n<p><code class=\\\"language-text\\\">cd ~/.ssh</code></p>\\n<p>Then run <code class=\\\"language-text\\\">ssh-keygen -t rsa</code> (-t rsa indicates rsa as encryption type)</p>\\n<p>The prompt will show a series of questions like which name you want to give to your key. <strong>Important</strong> in the naming step, make sure not to use the default value, because it's likely you already have such file created for other applications in your system. So just provide another name.</p>\",\"id\":\"/Users/zavareze/projects/zavjsblog/src/pages/2019-02-03-generating-ssh-key/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"Su, 02/19\",\"path\":\"/generating-an-ssh-key\",\"title\":\"Generating an SSH key\",\"excerpt\":\"Plain text password pose a series of security risks to server security. Using SSH is the best alternative to it. Let's learn how today\",\"tags\":[\"nginx\",\"ssh\"]}}],\"tagName\":\"nginx\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/tags-nginx.json\n// module id = 385\n// module chunks = 246017241436493"],"sourceRoot":""}