webpackJsonp([88196227997124],{376:function(n,a){n.exports={data:{markdownRemark:{html:'<p>Sometimes you don\'t want to delegate from a prototype, like mentioned <a href="/glossary-object-create">here</a> and <a href="/glossary-prototypes">here</a>. Instead, you want to have all properties of the prototype copied into the new object. That can be done with <code class="language-text">Object.assign</code>.</p>\n<p>Here\'s a possible implementation of such a behavior:</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">copyFrom</span> <span class="token operator">=</span> ref <span class="token operator">=></span>\n  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>\n    <span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>\n      <span class="token punctuation">{</span>\n        <span class="token operator">...</span>acc<span class="token punctuation">,</span>\n        <span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">:</span> ref<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p><a href="https://repl.it/@zavareze/Objectextend-Assign-Cloning">Live Code on Repl.it</a></p>\n<p>The difference between cloning and prototyping is that the latter is more memory efficient. So it\'s a good idea to use delegation for publicly shared methods, and cloning for properties in order to prevent shared state issues.</p>\n<p><strong>Important</strong>: just as seen previously, object and array direct assingments are shared between instances whereas replacements are instance-specific:</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> somePrototype <span class="token operator">=</span> <span class="token punctuation">{</span> skills<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"ray"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> inst1 <span class="token operator">=</span> <span class="token function">copyFrom</span><span class="token punctuation">(</span>somePrototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> inst2 <span class="token operator">=</span> <span class="token function">copyFrom</span><span class="token punctuation">(</span>somePrototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\ninst1<span class="token punctuation">.</span>skills<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"thunder"</span><span class="token punctuation">;</span>\n\n<span class="token comment">// did it affect \'inst2\'?</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inst2<span class="token punctuation">.</span>skills<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// \'thunder\' Yes, it did</span></code></pre>\n      </div>',frontmatter:{title:"Prototype and Clone",date:"February 03, 2019",path:"/prototype-cloning",tags:["prototypes","javascript"],excerpt:""}}},pathContext:{prev:{html:'<p>In this post we\'ll solve a small challenge: flatten an arbitrarily nested object into an array of values. Our initial goal should be to destructure the object, removing the keys and leaving values only.</p>\n<p>To achieve this, recursion. While traversing the object, we\'ll check if the object\'s property holds a simple value (like a number) or another object. We apply the function recursively until the returned value is a simple one.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  b<span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>\n  c<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    d<span class="token punctuation">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>\n    e<span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span>\n    f<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      g<span class="token punctuation">:</span> <span class="token string">"4"</span><span class="token punctuation">,</span>\n      h<span class="token punctuation">:</span> <span class="token string">"5"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  i<span class="token punctuation">:</span> <span class="token string">"6"</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">serialize</span> <span class="token operator">=</span> obj <span class="token operator">=></span>\n  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>key <span class="token operator">=></span>\n    <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">?</span> <span class="token function">serialize</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>If we test this function, we\'ll see it returns an array, and depending on the level of nesting, internal arrays as values. To make sure we always have a one-level array, our goal now is to flatten it.</p>\n<p>To do so, we\'ll use the example from a previous post <a href="/flattening-arbitrarily-nested-arrays">Flattening Arbitrarily Nested Arrays</a> to recursively flatten the array until the remaining value is not an array.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> arr <span class="token operator">=></span>\n  arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span>\n    acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">:</span> curr<span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>There you go. The flatten function simply verifies if the <code class="language-text">curr</code> value is an array or not. If it is, it will flatten it again by checking if its items are also arrays or not. That will be done until only simple values are returned. When that happens, <code class="language-text">curr</code> will be appended to the original accumulator (identified by the <code class="language-text">acc</code> parameter).</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">flatten</span><span class="token punctuation">(</span><span class="token function">serialize</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4, 5, 6]</span></code></pre>\n      </div>\n<h3>Composition</h3>\n<p>The initial challenge is solved. Now, to make this look better, why not use functional compositional to achieve a clearer, more beautiful execution order?</p>\n<p>Composition is about putting together small simple functions to achieve a more complex functionality while still maintaing readability. Remember the DOT and KISS principles, respectively <strong>"DO ONE THING"</strong> and <strong>"KEEP IT SIMPLE, STUPID"</strong>.</p>\n<p>Instead of writing one function that does everything, we write multiple functions that are really good at doing one thing only, and compose them together like lego bricks, into higher functionality.</p>\n<p>To achieve this, we\'ll create a composer function that, from an initial value will apply multiple functions in order:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">composer</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> funcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> funcs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">curr</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// es6 version</span>\n<span class="token keyword">const</span> <span class="token function-variable function">composer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> funcs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> curr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">curr</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>Then, we compose these two functions together and use the composer anytime we wish to do this same operation:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> objectFlattener <span class="token operator">=</span> <span class="token function">composer</span><span class="token punctuation">(</span>serialize<span class="token punctuation">,</span> flatten<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">objectFlattener</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4, 5, 6]</span></code></pre>\n      </div>',id:"/Users/zavareze/projects/zavjsblog/src/pages/2017-12-22-flattening-arbitrarily-nested-object/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"Fr, 12/17",path:"/flatenning-arbitrarily-nested-object",title:"Flattening an Arbitrarily Nested Object",excerpt:"In this post, we'll solve a small challenge: flatten an arbitrarily nested object into an array of values. Our initial goal should be to deestructure the object, removing the keys and leaving values only; then, we should be able to transform the nested array into a single-level array.",tags:["javascript"]}},next:null}}}});
//# sourceMappingURL=path---prototype-cloning-851bb83be82bbb64a847.js.map